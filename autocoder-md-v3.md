# 自動編碼助手 - 軟體開發文件

## 專案概述

自動編碼助手是一款命令列工具，類似Claude Code的功能，使用Python開發。該工具能夠根據特定格式的軟體開發文件自動生成代碼，並進行自動測試和驗證，直到代碼無錯誤為止。

## 核心功能 (參考Claude Code)

1. **命令列介面**: 直接在終端機中執行工具
2. **自動編碼**: 根據軟體開發文件自動生成程式碼
3. **自動測試**: 為生成的代碼自動創建和運行測試
4. **自我驗證**: 驗證生成的代碼是否符合需求
5. **自動修正**: 在發現錯誤時自動進行修正
6. **代碼理解**: 分析現有代碼庫並提供理解和文檔
7. **代碼重構**: 自動重構代碼以改進結構和效能
8. **錯誤診斷**: 識別和解釋代碼中的錯誤
9. **上下文理解**: 理解項目的整體背景和目標
10. **版本控制集成**: 與Git等版本控制系統集成
11. **互動式開發**: 允許用戶與AI進行對話式開發
12. **多語言支持**: 支持多種程式語言的代碼生成
13. **依賴管理**: 自動識別和安裝所需的依賴庫
14. **代碼註釋**: 自動為代碼添加詳細註釋
15. **代碼優化**: 識別並優化效能瓶頸

## 技術規格

### 基本規格
- **開發語言**: Python 3.9
- **AI模型**: qwen2.5-coder-32b-instruct-mlx
- **API呼叫**: 通過Open AI兼容API呼叫本地模型 (http://localhost:11434/v1)
- **最大測試次數**: 50次

### Qwen 2.5 Coder 模型特性與注意事項
- **模型優勢**: 
  - 支持超過30種程式語言，包括Python、JavaScript、Java、C++、Go等
  - 具備強大的代碼生成、理解和轉換能力
  - 支持上下文長度達128K tokens，適合處理較大的代碼庫
  - 支持多樣化的代碼任務，包括自動函數補全、程式解釋、代碼轉換等
  
- **調用配置**:
  - 建議使用400-800的temperature值區間以獲得最佳代碼質量
  - 系統提示詞(system prompt)精確定義輸出要求，以獲得最佳結果
  - 回歸測試時應使用固定的random seed以確保結果一致性
  
- **運行要求**:
  - 全參數運行需要約60GB顯存
  - 支持使用vLLM運行，提供更高的吞吐量和更低的延遲
  - 支持量化版本(INT4/INT8)，可在顯存有限的環境中運行
  
- **代碼生成最佳實踐**:
  - 提供詳細的功能描述和示例
  
- **存儲庫級別代碼補全**:
  - 在修復錯誤時，需要將項目的所有相關文件提供給模型
  - 排除不相關的文件，如`mermaid.md`、`specs`目錄、Git相關文件和目錄
  - 使用特殊標記`<|repo_name|>`和`<|file_sep|>`來指示存儲庫結構
  - 格式範例：
    ```
    <|repo_name|>專案名稱
    <|file_sep|>檔案路徑1
    檔案內容1
    <|file_sep|>檔案路徑2
    檔案內容2
    ...
    ```
  - 每次代碼生成迭代都應包含項目文件的上下文，以提高代碼質量和一致性

### 系統要求
- **操作系統**: 支援macOS 和 Linux
- **最低記憶體**: 8GB RAM (推薦 16GB+)
- **顯示卡**: 需要支援CUDA的GPU，推薦NVIDIA GPU，至少24GB顯存(INT8量化版本)，完整版本需要60GB顯存
- **存儲空間**: 最少 2GB 可用空間
- **處理器**: 多核心 CPU，推薦 4+ 核心

### 開發框架與庫
- **命令列解析**: argparse/click
- **HTTP 客戶端**: requests/httpx
- **測試框架**: pytest
- **代碼分析**: ast/astroid
- **並行處理**: asyncio
- **版本控制**: GitPython
- **文檔處理**: pyyaml/markdown
- **模型部署**: vLLM (用於高效部署Qwen 2.5 Coder)
- **量化工具**: AutoGPTQ/GPTQ (用於模型量化)

### 代碼質量標準
- **風格指南**: PEP 8
- **類型註解**: mypy 相容
- **測試覆蓋率**: 最低 85%
- **文檔標準**: Google 風格的 docstrings

### 安全性考量
- **API 密鑰管理**: 使用環境變數和加密存儲
- **代碼審查**: 生成的代碼經過安全性檢查
- **依賴管理**: 定期更新並檢查漏洞
- **代碼沙箱**: 隔離執行環境，防止惡意代碼執行

### 效能指標
- **回應時間**: 平均請求處理時間 < 2 秒
- **記憶體使用**: 峰值使用 < 500MB (不含模型)
- **並行能力**: 支援多任務並行處理
- **模型推理延遲**: 使用vLLM部署時，生成1000個tokens的平均時間 < 10秒

## 軟體開發文件規範

### 命名規範

開發文件必須遵循以下命名規範：
- 文件名格式：`[功能名稱]_spec.md`
- 目錄結構：專案根目錄下的 `specs/` 資料夾

### 格式要求

開發文件需包含以下部分：
- **專案元數據**：專案名稱、版本、作者
- **功能描述**：詳細的功能描述和目標
- **架構設計**：系統架構和組件關係
- **輸入/輸出規格**：詳細的輸入輸出格式和要求
- **技術要求**：語言、框架、庫和環境需求
- **測試案例**：預期行為和測試條件
- **相依性**：外部依賴和版本要求
- **錯誤處理**：異常情況和處理方式
- **性能要求**：效能和資源使用限制
- **介面定義**：API和使用者介面描述
- **代碼生成提示規範**：針對Qwen 2.5 Coder的最佳提示詞格式

### 代碼生成提示規範

為了最大化利用Qwen 2.5 Coder的能力，提示詞應包含以下元素：
- **任務定義**：明確說明要生成的代碼類型和目的
- **功能需求**：詳細列出所有必要的功能點
- **輸入輸出範例**：提供具體的輸入和預期輸出
- **代碼風格要求**：指定代碼風格、命名規範和文檔要求
- **相關依賴**：列出必要的庫和框架
- **錯誤處理要求**：指定如何處理異常情況
- **性能考量**：說明任何性能相關的限制或要求
- **測試案例**：提供關鍵測試案例供模型參考

## 工作流程

### 基本工作流程
1. 用戶啟動工具
2. 工具檢測並讀取指定目錄中的開發文件
3. 解析開發文件並理解需求
4. 調用AI模型生成代碼
5. 自動建立測試環境
6. 執行自動測試
7. 若測試失敗，分析錯誤並重新生成代碼
8. 重複步驟4-7，直到代碼通過所有測試或達到最大測試次數
9. 輸出最終代碼和測試報告

### Qwen 2.5 Coder 調用流程
1. 根據開發文件構建結構化的系統提示詞
2. 優化提示詞以包含所有必要的上下文和需求
3. 設置適當的模型參數（temperature、top_p等）
4. 通過API發送請求至本地部署的模型
5. 接收和解析模型響應
6. 驗證生成代碼的完整性和正確性
7. 必要時進行後處理和格式化

### 擴展工作流程 (參考Claude Code功能)

#### 代碼理解模式
1. 用戶提供現有代碼庫路徑
2. 工具掃描並分析代碼結構
3. 利用Qwen 2.5 Coder的128K上下文窗口處理大型代碼庫
4. 生成代碼理解報告和文檔
5. 識別潛在的改進點和優化機會

#### 重構模式
1. 用戶指定需要重構的代碼部分
2. 工具分析現有代碼及其依賴關係
3. 使用Qwen 2.5 Coder的代碼轉換能力生成重構建議和計劃
4. 執行重構並進行測試
5. 提供重構前後的比較報告

#### 互動式開發模式
1. 工具與用戶建立對話式介面
2. 用戶描述需求或提出問題
3. AI提供建議、生成代碼片段或解釋
4. 用戶給予反饋和確認
5. 迭代改進直到完成需求

#### 版本控制工作流程
1. 檢測並連接至項目的版本控制系統
2. 每次代碼生成或修改後創建合適的提交
3. 利用Qwen 2.5 Coder生成符合項目風格的提交訊息
4. 提供分支管理和合併建議

## 使用者互動

### 基本互動原則
- 整個開發過程為自動同意變更，自動完成
- 只有在安裝依賴套件時需要用戶同意

### 命令列介面設計
- **幫助命令**: `autocoder --help` 顯示所有可用命令和選項
- **生成模式**: `autocoder generate <spec_path> [--output-dir <output_directory>]` 根據規格文件生成代碼
  - `<spec_path>`: 規格文件的路徑
  - `--output-dir <output_directory>`: 生成代碼的輸出目錄（如果目錄不存在則自動創建）
- **理解模式**: `autocoder understand <code_path>` 分析現有代碼並生成文檔
- **重構模式**: `autocoder refactor <code_path> [--target <target>]` 重構指定代碼
- **測試模式**: `autocoder test <code_path>` 為指定代碼生成和執行測試
- **互動模式**: `autocoder interactive` 啟動互動式開發對話
- **模型配置**: `autocoder config --model <model_path> --api <api_endpoint>` 配置模型參數

### 全域選項
- **-v, --verbose**: 啟用詳細輸出模式，顯示完整過程和結果
  - 顯示環境信息（Python版本、操作系統、工作目錄）
  - 顯示配置信息（API端點、溫度等參數）
  - 顯示所有執行的命令及其輸出
  - 顯示詳細的執行時間統計
  - 顯示命令執行歷史記錄
- **-q, --quiet**: 最小化輸出，只顯示錯誤和關鍵訊息
- **--no-color**: 禁用顏色輸出

### 模型相關配置選項
- **--temperature**: 設置模型生成的隨機性 (0.0-1.0)，默認0.6
- **--top-p**: 設置模型生成的多樣性 (0.0-1.0)，默認0.9
- **--max-tokens**: 設置最大生成token數量，默認8192
- **--quantize**: 選擇量化級別 (none/int8/int4)，默認none
- **--system-prompt**: 使用自定義系統提示詞
- **--seed**: 設置隨機種子以確保結果一致性

### 輸出格式
- **顏色編碼**: 使用不同顏色標記不同類型的輸出 (錯誤、警告、成功)
- **進度指示**: 在長時間操作期間顯示進度條或動畫
- **詳細程度控制**: `--verbose`, `--quiet` 選項控制輸出細節

### 錯誤處理和提示
- 清晰的錯誤訊息，包含問題描述和可能的解決方案
- 在操作前提供操作摘要和確認提示 (可通過 `--yes` 跳過)
- 意外終止時提供恢復選項和狀態保存

### 設定和自訂
- 支援配置文件 (`~/.autocoder.yaml`) 用於個人化設定
- 支援項目級別配置 (項目目錄中的 `.autocoder.yaml`)
- 允許通過環境變數覆蓋配置 (`AUTOCODER_*`)
- 支援模型參數自定義 (`MODEL_*` 環境變數)

## 待實現功能子任務

### 1. 命令列介面設計與實現
- 1.1. 命令列參數解析系統
- 1.2. 幫助文檔和使用指南
- 1.3. 顏色化輸出和進度展示
- 1.4. 互動式提示和確認機制

### 2. 開發文件解析器
- 2.1. 文件格式定義與驗證
- 2.2. 需求和規格提取
- 2.3. 關鍵字和標籤識別
- 2.4. 優先級和依賴關係解析

### 3. AI模型連接與請求處理
- 3.1. API客戶端設計
- 3.2. 請求格式化和優化
- 3.3. 響應解析和處理
- 3.4. 錯誤處理和重試機制
- 3.5. 上下文管理和記憶功能
- 3.6. **Qwen 2.5 Coder特定提示詞優化**
- 3.7. **模型參數動態調整**
- 3.8. **量化模型支持**
- 3.9. **vLLM部署集成**

### 4. 代碼生成器
- 4.1. 程式碼模板系統
- 4.2. 語法樹生成與操作
- 4.3. 代碼格式化和優化
- 4.4. 多語言支持架構
- 4.5. 代碼註釋自動生成
- 4.6. **大型代碼庫上下文管理**
- 4.7. **代碼任務分解與重組**

### 5. 測試框架整合
- 5.1. 單元測試生成器
- 5.2. 集成測試生成器
- 5.3. 測試案例優先級管理
- 5.4. 測試覆蓋率分析
- 5.5. 邊界情況檢測
- 5.6. **自動化測試優化**

### 6. 錯誤分析與修復機制
- 6.1. 錯誤模式識別
- 6.2. 根本原因分析
- 6.3. 修復策略生成
- 6.4. 代碼修補和重構
- 6.5. 學習和改進機制
- 6.6. **模型反饋優化循環**

### 7. 代碼理解與重構
- 7.1. 現有代碼庫分析
- 7.2. 代碼結構可視化
- 7.3. 重構建議生成
- 7.4. 代碼質量評估
- 7.5. 文檔自動生成
- 7.6. **大型代碼庫分塊處理**

### 8. 版本控制集成
- 8.1. Git操作封裝
- 8.2. 分支管理和合併策略
- 8.3. 提交消息生成
- 8.4. 衝突解決輔助

### 9. 進度報告與日誌系統
- 9.1. 實時進度追踪
- 9.2. 結構化日誌記錄
- 9.3. 報告生成和匯出
- 9.4. 性能指標收集
- 9.5. **模型調用效能監控**

### 10. 套件管理與安裝處理
- 10.1. 依賴分析和解析
- 10.2. 虛擬環境管理
- 10.3. 安裝腳本生成
- 10.4. 版本兼容性檢查
- 10.5. **GPU環境配置檢測**